from Crypto.Util.number import long_to_bytes
import gmpy2

# 已知的 n, e, c
n=109034687395427799627751475690813559772337298379935606615501069153459469672290998250813248499572280048072211075225668626417839338768434118745170138435443452361100112911279507376918106721054953015793019581244915528620953085390376959391149321905804163000092070553285213405885239507405130454181180309461332663843
e=53474198347015672653407631846720112439749318632127611513223800376674441979550781308438704211625857705819169332362653348196878046820219526711362117095376680199197221858759359117876407260242155020858972474194983327507336630367744335194518313431132085497021146495778107676673201691126117464632153693786119724477
c=64445249097576239874178452699949657095419208925569284496148798554847418043588948616627453750695681730807461912235204446631628388651198278474365539522978872509391746497990305136795385345297631450380023696025582926141256711839460506247545053822153704572118026494854796164718134040086694871634621160124708947312

# Step 1: 使用低私钥指数攻击恢复 d
def find_private_key(n, e):
    """
    尝试使用低私钥指数攻击恢复 d。
    """
    # 使用 gmpy2 来快速计算 gcd 和扩展欧几里得算法
    # 尝试找到一个满足条件的 d
    phi_n_guess = 1
    for d in range(1, 100000):  # 这里假设d的大小在这个范围内，可以调整范围
        # 计算 d 和 e 的乘积，检验是否是 n 的私钥
        if gmpy2.invert(e, phi_n_guess) == d:
            return d
    return None  # 如果无法找到私钥 d，返回 None

# Step 2: 解密密文
def decrypt(c, d, n):
    """
    使用私钥 d 解密密文 c。
    """
    m = pow(c, d, n)
    return long_to_bytes(m)

# Step 3: 调用相关函数
# 在这里你可以选择合适的范围来遍历可能的 d

d = find_private_key(n, e)  # 寻找私钥 d

if d is not None:
    print(f"Found private key d: {d}")
    # 使用恢复的私钥 d 解密密文 c
    flag = decrypt(c, d, n)
    print(f"Flag: {flag.decode()}")
else:
    print("Could not find private key d")
